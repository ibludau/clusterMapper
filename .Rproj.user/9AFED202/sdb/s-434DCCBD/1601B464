{
    "collab_server" : "",
    "contents" : "mapClusters <- function(table, sort_RT=FALSE){\n  features <- copy(table)\n  ## count number of clusters per run and collapsed peptide\n  features[, cluster_count_per_run := uniqueN(Cluster), by = c(\"run_id\",\"Collapsed_Peptide\")]\n  ## count total number of clusters across all runs\n  features[, cluster_count_total := max(cluster_count_per_run), by = c(\"Collapsed_Peptide\")]\n  ## if only one cluster across all runs, new cluster is 1\n  features[ , new_cluster := ifelse(cluster_count_total == 1, 1, 0)]\n  featuresDone <- subset(features, new_cluster != 0)\n\n  ###############################################################\n  ## Continue with data requiring matching ######################\n  ###############################################################\n  ## subset features to contain only cluster that still need to be matched\n  featuresSubset <- subset(features, new_cluster == 0)\n  ## tg count per cluster, run and collapsed peptide\n  featuresSubset[, tg_count_per_cluster := uniqueN(transition_group_id), by = c(\"run_id\",\"Collapsed_Peptide\",\"Cluster\")]\n  ## tg count per run and collapsed peptide\n  featuresSubset[, tg_count_per_peptide := uniqueN(transition_group_id), by = c(\"run_id\",\"Collapsed_Peptide\")]\n\n  ###############################################################\n  ## Determine reference run for each collapsed peptide #########\n  ###############################################################\n  ## select one of the remaining runs as reference\n  featuresSubsetTop <- copy(featuresSubset)\n  featuresSubsetTop <- unique(featuresSubsetTop, by=c(\"run_id\",\"Collapsed_Peptide\"))\n  ## select most frequent cluster number\n  getMostFrequentCluster <- function(X){as.numeric(names(sort(table(X),decreasing=TRUE))[1])}\n  featuresSubsetTop[ , `:=` (freqCluster = getMostFrequentCluster(cluster_count_per_run)) , by = c(\"Collapsed_Peptide\") ]\n  ## Select reference run:\n  ## most frq cluster count\n  featuresSubsetTopSub <- subset(featuresSubsetTop, cluster_count_per_run == freqCluster)\n  ## most transition groups\n  featuresSubsetTopSub[ , maxTgCount := max(tg_count_per_peptide) , by = .(Collapsed_Peptide) ]\n  featuresSubsetTopSub <- subset(featuresSubsetTopSub, tg_count_per_peptide == maxTgCount)\n  ## select one of the remaining runs as reference\n  featuresSubsetTopSub <- unique(featuresSubsetTopSub, by=c(\"Collapsed_Peptide\"))\n  ## This table now contains one reference run per collapsed peptide\n\n  ###############################################################\n  ## Generate RT sorted cluster names for each reference run ####\n  ###############################################################\n  ## Generate a full reference table with a cluster assigned to each transition group base don the RT dimension\n  featuresSubset[, unique_key := paste(Collapsed_Peptide,run_id,sep=\"_\")]\n  featuresSubset[, meanClusterRT := mean(RT), by=c(\"unique_key\",\"Cluster\")]\n  featuresSubset[, clusterRank := frank(meanClusterRT,ties.method=\"dense\"), by=c(\"unique_key\")]\n\n  featuresSubsetTopSub[, unique_key := paste(Collapsed_Peptide,run_id,sep=\"_\")]\n  referenceData <- copy(featuresSubset)\n  referenceData <- subset(referenceData, unique_key %in% featuresSubsetTopSub$unique_key)\n  if (sort_RT) {\n    referenceData[, new_cluster := clusterRank]\n  } else {\n  ## Using clusters sorted by RT might be better, but this wasn't used for original data analysis\n  ## Use sort_RT=FALSE to reproduce previous results\n    referenceData[, new_cluster := as.numeric(gsub(\"cluster\",\"\",Cluster))+1]\n    featuresSubset[, clusterRank := as.numeric(gsub(\"cluster\",\"\",Cluster))+1]\n  }\n\n  ###############################################################\n  ## Map each test run to the reference #########################\n  ###############################################################\n  x <- featuresSubset[, mapToReference(.SD,reference = referenceData, sort_RT = FALSE), by=.(Collapsed_Peptide,run_id), .SDcols=c(names(featuresSubset))]\n  out <- rbind(featuresDone,x, fill=TRUE)\n  return(out)\n}\n\nmapToReference <- function(test, reference, sort_RT){\n  testSub <- copy(test)\n  referenceSub <- copy(reference)\n  referenceSub <- subset(referenceSub, Collapsed_Peptide==unique(testSub$Collapsed_Peptide))\n  if ((all(referenceSub$cluster_count_per_run == 1)) & (all(testSub$cluster_count_per_run == 1))) {\n    testSub[, new_cluster := 1]\n    return(testSub)\n  } else {\n    clusterNum_ref=unique(referenceSub$cluster_count_per_run)\n    clusterNum_test=unique(testSub$cluster_count_per_run)\n    vote=matrix(data=0,nrow=clusterNum_ref[1],ncol=clusterNum_test[1])\n    for (l in 1:clusterNum_ref[1]) { # go through all clusters in reference\n      #ref_ids = subset(referenceSub,new_cluster == l)$transition_group_id\n      cluster_ref <- unique(referenceSub$new_cluster)\n      ref_ids = subset(referenceSub,clusterRank == cluster_ref[l])$transition_group_id\n      if(length(ref_ids) < 2) { ################# @TODO think about this!!!!!!!!!!\n        next\n      }\n      #idx_ref_cluster <- which(data$Cluster == ref_cluster[l])\n      #cluster_new[Reduce(intersect, list(idx_cp,idx_ref_run,idx_ref_cluster))] = l\n      for (m in 1:clusterNum_test[1]) {\n        cluster_test <- unique(testSub$clusterRank)\n        test_ids = subset(testSub, clusterRank == cluster_test[m])$transition_group_id\n        #idx_test_cluster <- which(data$Cluster == test_cluster[m])\n        if(length(test_ids) < 2) {\n          next\n        }\n        for (n in 1:length(test_ids)){ # go over all treansition_group_ids in test run\n          if (test_ids[n] %in% ref_ids){\n            vote[l,m] = vote[l,m]+1\n            #print(paste0(vote[l,m], \" and \",length(test_ids), \" and \",test_ids[n]))\n          }\n          if (vote[l,m] > length(test_ids)/2) {\n            testSub$new_cluster[which(testSub$clusterRank == cluster_test[m])] = l\n            #if (sort_RT) {\n            #  testSub$new_cluster[which(testSub$clusterRank == m)] = l\n            #} else {\n            #  testSub$new_cluster[which(testSub$clusterRank == m)] = referenceSub$new_cluster[which(referenceSub$new_cluster == l)][1]\n            #}\n            #print(paste0(\"break \",l,\" \",m))\n            break\n          }\n        }\n      }\n    }\n    return(testSub)\n  }\n}\n\n\n\n\n\n\n",
    "created" : 1501585624563.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "793539775",
    "id" : "1601B464",
    "lastKnownWriteTime" : 1501595099,
    "last_content_update" : 1501595100601,
    "path" : "/Volumes/ibludau-1/clusterMapper/clusterMapper/R/mapClusters.R",
    "project_path" : "R/mapClusters.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}